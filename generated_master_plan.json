{
  "CompilationUnit": "1. **Goal:** Process all program units within the compilation unit.\n2. **Implementation:**\n   - This is the root of the AST.\n   - Initialize the `path_condition` to a base state: `path_condition = z3.BoolVal(True)`.\n   - Iterate through all `ProgramUnit` children.\n   - For each child, call `self.visit(child, path_condition)` to recursively process it.\n   - After visiting all children, call `self.finalize_and_add_to_solver()` to combine all path-specific constraints into the main Z3 solver.",
  "ProgramUnit": "1. **Goal:** Process the data and procedure divisions of a single COBOL program.\n2. **Implementation:**\n   - This node acts as a container. The order of processing is critical.\n   - **First Pass (Declarations):**\n     - Find the `DataDivision` child node.\n     - If found, call `self.visit(data_division_node, path_condition)`. This must happen first to populate `self.pic_info` and `self.declarations`.\n   - **Second Pass (Logic):**\n     - Find the `ProcedureDivision` child node.\n     - If found, call `self.visit(procedure_division_node, path_condition)`. This pass will use the declarations from the first pass.\n   - Visit any nested `ProgramUnit` children by calling `self.visit(child, path_condition)`.\n   - Visit the `EndProgramStatement` by calling `self.visit(child, path_condition)`.",
  "EndProgramStatement": "1. **Goal:** Mark the end of a program unit's definition.\n2. **Implementation:**\n   - This node is primarily for program structure validation, which is assumed to be done by the parser.\n   - In this visitor, simply log that the end of the program was reached, if desired.\n   - No Z3 variables or constraints are generated here.",
  "DataDivision": "1. **Goal:** Process all sections within the Data Division.\n2. **Implementation:**\n   - This node orchestrates the processing of all data declarations.\n   - Set a flag to indicate the visitor is in a declaration context: `self._is_in_declaration_context = True`.\n   - Iterate through all `DataDivisionSection` children.\n   - For each child, call `self.visit(child, path_condition)`.\n   - After visiting all children, unset the flag: `self._is_in_declaration_context = False`.",
  "DataDivisionSection": "1. **Goal:** Process a specific data section (Working-Storage, Linkage, etc.).\n2. **Implementation:**\n   - This is a wrapper node.\n   - Call `self.visit` on its single child (e.g., `WorkingStorageSection`) to process the actual content: `self.visit(self._get_first_child(node), path_condition)`.",
  "WorkingStorageSection": "1. **Goal:** Process all data items declared in the Working-Storage Section.\n2. **Implementation:**\n   - Iterate through all `DataDescriptionEntry` children.\n   - For each child, call `self.visit(child, path_condition)` to declare the variable and its associated constraints.",
  "LinkageSection": "1. **Goal:** Process all data items declared in the Linkage Section.\n2. **Implementation:**\n   - Iterate through all `DataDescriptionEntry` children.\n   - For each child, call `self.visit(child, path_condition)`.\n   - **Note:** The semantics of Linkage Section items (as pointers/parameters) might require special handling in a more advanced implementation, but for this plan, they are treated as standard declarations.",
  "LocalStorageSection": "1. **Goal:** Process all data items declared in the Local-Storage Section.\n2. **Implementation:**\n   - Iterate through all `DataDescriptionEntry` children.\n   - For each child, call `self.visit(child, path_condition)`.",
  "DataDescriptionEntry": "1. **Goal:** Act as a dispatcher for different data description formats.\n2. **Implementation:**\n   - This is a wrapper node.\n   - Call `self.visit` on its single child, `DataDescriptionEntryFormat1`: `self.visit(self._get_first_child(node), path_condition)`.",
  "DataDescriptionEntryFormat1": "1. **Goal:** This is the core of data declaration. Parse a data item, create its dual Z3 representation (Logical and Physical), and add linking constraints.\n2. **Implementation:**\n   - **Step 1: Extract Basic Info**\n     - Get the level number (e.g., '01', '77') from the `INTEGERLITERAL` or `LEVEL_NUMBER_77` child.\n     - Find the `DataName` child node. If it's absent or a `FILLER` node is present, generate a unique internal name (e.g., `__FILLER_1`). This name will be the `base_name`.\n\n   - **Step 2: Manage Hierarchy and Naming**\n     - Use the level number to manage the `self._current_group_context` stack.\n     - Pop items from the stack that have a level number greater than or equal to the current level.\n     - Construct the `full_name` by joining the names from the context stack with the current `base_name`, separated by dots (e.g., `GROUP-1.ITEM-A`).\n\n   - **Step 3: Handle Group vs. Elementary Items**\n     - Check for the presence of a `DataPictureClause`. \n     - **If NO `DataPictureClause` (Group Item):**\n       - This is a group item. Add its info (level, `full_name`) to the `self._current_group_context` stack.\n       - Do not create Z3 variables for the group itself, only for its elementary children. Skip to the end.\n     - **If YES `DataPictureClause` (Elementary Item):**\n       - Proceed with elementary item processing.\n\n   - **Step 4: Parse Clauses & Build `pic_info`**\n     - Set a temporary tracker: `self._current_data_item_being_declared = full_name`.\n     - Create a `pic_info` dictionary for this `full_name` and initialize with defaults.\n     - Store `name`, `level` and the raw `original_pic` string.\n     - **Define a helper function `_parse_pic_string(pic_str)` within this visitor:**\n       - This function expands cardinalities (e.g., `9(3)` to `999`), counts digits, identifies sign (`S`), decimal (`V` or `.`), and character types (`9`, `X`, `A`, `Z`, `*`, etc.).\n       - It populates the `expanded_pic`, `category`, `is_signed`, `has_decimal`, `is_edited`, `total_digits`, `integer_digits`, `decimal_places`, and `char_length` fields in the `pic_info` dictionary.\n     - Call this helper by visiting the `DataPictureClause` child and passing its `PictureString` text.\n     - Visit other clauses (`DataUsageClause`, `DataSignClause`) and update `pic_info` accordingly. The `DataUsageClause` is critical for determining the physical memory layout.\n     - Store the completed `pic_info` dictionary in `self.pic_info[full_name]`.\n\n   - **Step 5: Create Z3 Logical Variable**\n     - Based on `pic_info['category']`:\n       - **Numeric (`numeric`, `edited`):** Create a `z3.Int` variable. `logical_var = z3.Int(full_name)`.\n       - **Alphanumeric/Alphabetic (`alphanumeric`, `alphabetic`):** Create a `z3.String` variable. `logical_var = z3.String(full_name)`.\n     - Add to declarations: `self._add_declaration(full_name, logical_var)`.\n\n   - **Step 6: Create Z3 Physical Variable**\n     - Determine the byte size based on `pic_info` and USAGE. Define a helper function `_get_byte_size(info)` for this.\n       - `USAGE DISPLAY`: `byte_size = info['char_length']`.\n       - `USAGE BINARY/COMP/COMP-4/COMP-5`: `byte_size = 2` if digits <= 4, `4` if digits <= 9, `8` otherwise.\n       - `USAGE PACKED-DECIMAL/COMP-3`: `byte_size = ceil((info['total_digits'] + 1) / 2)`.\n     - Create a Bit Vector: `physical_var = z3.BitVec(f'{full_name}_phys', byte_size * 8)`.\n     - Add to declarations: `self._add_declaration(f'{full_name}_phys', physical_var)`.\n\n   - **Step 7: Add Linking and Range Constraints**\n     - **Define helper functions for EBCDIC encoding/decoding within the visitor.**\n     - Based on `pic_info` and USAGE, generate constraints linking `logical_var` and `physical_var`.\n       - **`USAGE DISPLAY` (Zoned Decimal):** Create constraints that model EBCDIC zoned decimal format. For each byte in `physical_var`, constrain the high nibble (zone) and low nibble (digit). The sign is in the zone of the last byte (`0xF` for unsigned/positive, `0xD` for negative).\n       - **`USAGE BINARY`:** `physical_var == z3.Int2BV(logical_var, byte_size * 8)`. Add range constraints for the logical variable based on the PIC clause, e.g., `z3.And(logical_var >= -999, logical_var <= 999)` for `PIC S9(3)`.\n       - **`USAGE PACKED-DECIMAL`:** Create constraints modeling the BCD layout. Each nibble of `physical_var` represents a digit, with the last nibble representing the sign (`0xC` for positive, `0xD` for negative, `0xF` for unsigned).\n     - Add all generated constraints to the main list using `self._add_constraint(constraint, path_condition)`.\n\n   - **Step 8: Process `DataValueClause`**\n     - **Crucially, this happens AFTER declaration.**\n     - Find and visit the `DataValueClause` child. This visit will return a Z3 literal value.\n     - Create a new version of the variable to handle initialization: `init_var = self._create_new_z3_var(full_name)`.\n     - Create an assignment constraint: `constraint = (init_var == returned_z3_literal)`.\n     - Add this constraint using `self._add_constraint(constraint, path_condition)`.\n\n   - **Step 9: Cleanup**\n     - Reset the tracker: `self._current_data_item_being_declared = None`.",
  "DataPictureClause": "1. **Goal:** Extract the raw PIC string.\n2. **Implementation:**\n   - Find the `PictureString` child node.\n   - Extract the `Source Text` from the `PictureString` node.\n   - Return this raw string to the calling visitor (`DataDescriptionEntryFormat1`). This method does not modify any global state.",
  "PictureString": "1. **Goal:** Assemble the complete PIC string from its parts.\n2. **Implementation:**\n   - This visitor should not be called directly; its text is extracted by its parent `DataPictureClause`.\n   - If called, it would iterate its children (`PictureChars`, `PictureCardinality`) and concatenate their `Source Text` to form the full string.",
  "PictureChars": "1. **Goal:** Represent a character in a PIC string.\n2. **Implementation:**\n   - This visitor should not be called directly. Its `Source Text` is used by its parent.",
  "PictureCardinality": "1. **Goal:** Represent a repetition factor like `(9)` in `PIC 9(9)`.\n2. **Implementation:**\n   - This visitor should not be called directly. Its `Source Text` is used by its parent.",
  "DataRedefinesClause": "1. **Goal:** Handle the REDEFINES clause by aliasing memory.\n2. **Implementation:**\n   - **Note:** This is an advanced feature.\n   - Get the name of the data item being redefined from the `DataName` child.\n   - Find the physical Z3 variable of the redefined item (e.g., `redefined_item_phys`).\n   - When the current (redefining) item's physical variable is created in `DataDescriptionEntryFormat1`, instead of creating a new `z3.BitVec`, alias the existing one: `current_item_phys = redefined_item_phys`.\n   - If the sizes differ, create a constraint using `z3.Extract` to alias only the relevant portion of the memory.\n   - The logical variable for the redefining item is created as usual, but its linking constraints will be against the *shared* physical variable.",
  "DataRenamesClause": "1. **Goal:** Handle the RENAMES clause.\n2. **Implementation:**\n   - This is primarily for creating a new logical grouping of existing elementary items. \n   - Identify the start and (optional) end `QualifiedDataName`s.\n   - This does not create new Z3 variables. It establishes a new name that refers to a range of existing items. This logic is complex and would be handled during variable resolution (`self.resolve_variable`) rather than by generating new constraints.",
  "DataSignClause": "1. **Goal:** Parse the SIGN IS clause to inform sign representation.\n2. **Implementation:**\n   - Find the `LEADING` or `TRAILING` keywords.\n   - Find the `SEPARATE CHARACTER` phrase.\n   - Return a dictionary like `{'position': 'leading'/'trailing', 'is_separate': True/False}` to the calling `DataDescriptionEntryFormat1` visitor.\n   - This information will be used in `DataDescriptionEntryFormat1` to correctly model the `USAGE DISPLAY` physical layout and to adjust `char_length` in `pic_info` if the sign is separate.",
  "DataUsageClause": "1. **Goal:** Parse the USAGE clause to determine the physical data representation.\n2. **Implementation:**\n   - Get the `Source Text` of the usage type (e.g., `COMP-3`, `BINARY`, `DISPLAY`).\n   - Normalize the text to a standard internal representation (e.g., 'BINARY', 'PACKED-DECIMAL', 'DISPLAY').\n   - Return this normalized string to the `DataDescriptionEntryFormat1` visitor to be stored in `pic_info`.",
  "DataValueClause": "1. **Goal:** Parse the VALUE IS clause and return the corresponding Z3 literal.\n2. **Implementation:**\n   - This is called by `DataDescriptionEntryFormat1` *after* the variable has been declared.\n   - Visit the `DataValueInterval` child (or children).\n   - The visit to `DataValueInterval` will return a Z3 literal (e.g., `z3.IntVal(123)`, `z3.StringVal('HELLO')`).\n   - Return this Z3 literal to the caller.\n   - Note: The grammar supports ranges (`THRU`), which are typically for `LEVEL 88` condition names. This plan focuses on simple initialization values.",
  "DataValueInterval": "1. **Goal:** Parse a literal value or a range.\n2. **Implementation:**\n   - Visit the `DataValueIntervalFrom` child. This will return a Z3 literal.\n   - If a `DataValueIntervalTo` child exists, this indicates a range (for LEVEL 88 items). For standard initialization, this is ignored.\n   - Return the Z3 literal obtained from `DataValueIntervalFrom`.",
  "DataValueIntervalFrom": "1. **Goal:** Get the Z3 representation of a literal.\n2. **Implementation:**\n   - Get the child node, which is either a `literal` or a `cobolWord`.\n   - Visit this child by calling `self.visit(child, path_condition)`.\n   - The visit will return a Z3 literal. Return this value.",
  "DataValueIntervalTo": "1. **Goal:** Parse the `THRU` part of a value range.\n2. **Implementation:**\n   - Currently, this plan does not implement `LEVEL 88` condition names in detail.\n   - If implemented, this would visit the `literal` child to get the upper bound of the range.",
  "ProcedureDivision": "1. **Goal:** Process the logic within the Procedure Division.\n2. **Implementation:**\n   - Visit the `ProcedureDivisionBody` child node by calling `self.visit(child, path_condition)`.",
  "ProcedureDivisionBody": "1. **Goal:** Process all paragraphs and sections in the procedure division body.\n2. **Implementation:**\n   - Simply visit all children (`Paragraphs`, `ProcedureSection`) in order by calling `self.visit(child, path_condition)`.",
  "ProcedureSection": "1. **Goal:** Process a named section of paragraphs.\n2. **Implementation:**\n   - This provides a scope for paragraph names.\n   - Visit the `Paragraphs` child by calling `self.visit(child, path_condition)`.",
  "Paragraphs": "1. **Goal:** Process a sequence of sentences and paragraphs.\n2. **Implementation:**\n   - Iterate through all `Sentence` and `Paragraph` children in order.\n   - For each child, call `self.visit(child, path_condition)`.",
  "Paragraph": "1. **Goal:** Process a named paragraph.\n2. **Implementation:**\n   - Iterate through all `Sentence` children.\n   - For each child, call `self.visit(child, path_condition)`.",
  "Sentence": "1. **Goal:** Process a sequence of statements ending in a period.\n2. **Implementation:**\n   - Iterate through all `Statement` children.\n   - For each child, call `self.visit(child, path_condition)`.",
  "Statement": "1. **Goal:** Dispatch to the specific statement visitor.\n2. **Implementation:**\n   - This is a wrapper node.\n   - Call `self.visit` on its single child (e.g., `MoveStatement`, `IfStatement`): `self.visit(self._get_first_child(node), path_condition)`.",
  "ComputeStatement": "1. **Goal:** Generate constraints for an arithmetic computation and assignment.\n2. **Implementation:**\n   - **Step 1: Evaluate RHS**\n     - Visit the `ArithmeticExpression` child. This will return a Z3 expression representing the result of the calculation (e.g., `z3_expr`).\n   - **Step 2: Assign to LHS**\n     - Get the list of `ComputeStore` children (the identifiers to store the result in).\n     - For each `ComputeStore` child:\n       - Visit the child to get the base variable name.\n       - **Note on ROUNDED:** If the `ROUNDED` keyword is present, the logic needs to be adjusted. The returned `z3_expr` from `ArithmeticExpression` might be a `z3.Real` if division is involved. The implementation would need to add 0.5 and truncate. For `z3.Int` expressions, this is more complex and may require modeling fixed-point arithmetic.\n       - Create a new version for the LHS variable: `lhs_var = self._create_new_z3_var(base_name)`.\n       - Create the assignment constraint: `assignment_constraint = (lhs_var == z3_expr)`.\n       - Add the constraint to the current path using `self._add_constraint(assignment_constraint, path_condition)`.\n   - **Step 3: Handle ON SIZE ERROR (Future Enhancement)**\n     - This would involve checking if `z3_expr` exceeds the capacity of the receiving variable (based on `pic_info`). A conditional constraint would be generated.",
  "ComputeStore": "1. **Goal:** Identify the target variable for a COMPUTE statement.\n2. **Implementation:**\n   - Visit the `Identifier` child to get the variable name.\n   - Return the resolved variable name string.",
  "DisplayStatement": "1. **Goal:** Model a DISPLAY statement.\n2. **Implementation:**\n   - This is primarily an I/O operation. In a pure logic/constraint context, this might be modeled as an assertion or simply logged.\n   - For each `DisplayOperand` child:\n     - Visit the child to get its Z3 representation (either a variable's value or a literal).\n     - Log the 'display' action with the Z3 expression. No constraints are added to the solver.",
  "DisplayOperand": "1. **Goal:** Get the Z3 value of an item to be displayed.\n2. **Implementation:**\n   - Visit the `Identifier` or `literal` child by calling `self.visit(child, path_condition)`.\n   - This will return the Z3 expression for the variable's current value or the Z3 literal.\n   - Return this Z3 expression.",
  "DisplayAt": "1. **Goal:** Handle the AT phrase.\n2. **Implementation:**\n   - Log this information. No Z3 constraints generated.",
  "DisplayUpon": "1. **Goal:** Handle the UPON phrase.\n2. **Implementation:**\n   - Log this information. No Z3 constraints generated.",
  "DisplayWith": "1. **Goal:** Handle the WITH NO ADVANCING phrase.\n2. **Implementation:**\n   - Log this information. No Z3 constraints generated.",
  "IfStatement": "1. **Goal:** Handle conditional logic by splitting execution paths.\n2. **Implementation:**\n   - **Step 1: Evaluate Condition**\n     - Visit the `Condition` child. This will return a Z3 boolean expression representing the condition (`if_cond`).\n   - **Step 2: Process THEN Branch**\n     - Create a new path condition for the 'then' branch: `then_path = z3.And(path_condition, if_cond)`.\n     - Find the `IfThen` child node.\n     - Visit the `IfThen` child, passing the new `then_path`: `self.visit(if_then_node, then_path)`.\n   - **Step 3: Process ELSE Branch**\n     - Find the `IfElse` child node.\n     - **If `IfElse` exists:**\n       - Create a new path condition for the 'else' branch: `else_path = z3.And(path_condition, z3.Not(if_cond))`.\n       - Visit the `IfElse` child, passing the new `else_path`: `self.visit(if_else_node, else_path)`.\n   - **Note:** The results from visiting the branches (new constraints) are stored in `self.path_constraints` keyed by their respective path conditions. The `IfStatement` visitor itself doesn't return anything.",
  "IfThen": "1. **Goal:** Process the statements in the THEN block of an IF statement.\n2. **Implementation:**\n   - Check for `NEXT SENTENCE`. If present, do nothing.\n   - Otherwise, iterate through all `Statement` children.\n   - For each statement, call `self.visit(child, path_condition)`, passing down the `then_path` received from the `IfStatement` visitor.",
  "IfElse": "1. **Goal:** Process the statements in the ELSE block of an IF statement.\n2. **Implementation:**\n   - Check for `NEXT SENTENCE`. If present, do nothing.\n   - Otherwise, iterate through all `Statement` children.\n   - For each statement, call `self.visit(child, path_condition)`, passing down the `else_path` received from the `IfStatement` visitor.",
  "MoveStatement": "1. **Goal:** Dispatch to the correct MOVE statement handler.\n2. **Implementation:**\n   - Check for the presence of a `MoveToStatement` or `MoveCorrespondingToStatement` child.\n   - Call `self.visit` on that child, passing the `path_condition`.",
  "MoveToStatement": "1. **Goal:** Generate constraints for a `MOVE val TO var1, var2...` statement.\n2. **Implementation:**\n   - **Step 1: Get Sending Value**\n     - Visit the `MoveToSendingArea` child. This will return the Z3 expression of the value being moved (`rhs_expr`).\n   - **Step 2: Assign to Receiving Variables**\n     - Get the list of `Identifier` children that are receiving the value.\n     - For each `Identifier` child:\n       - Visit the identifier to get its base name.\n       - Create a new version for this receiving variable: `lhs_var = self._create_new_z3_var(base_name)`.\n       - Create the assignment constraint: `assignment_constraint = (lhs_var == rhs_expr)`.\n       - **Type Conversion:** The `==` is a simplification. The COBOL semantics dictate conversions. For example, moving a string to a numeric field requires de-editing. The constraint must model this. `assignment_constraint = (lhs_var == convert_to_numeric(rhs_expr))` where `convert_to_numeric` is a helper function that models this logic.\n       - Add the constraint using `self._add_constraint(assignment_constraint, path_condition)`.",
  "MoveToSendingArea": "1. **Goal:** Get the Z3 value of the sending item in a MOVE.\n2. **Implementation:**\n   - Visit the `Identifier` or `literal` child by calling `self.visit(child, path_condition)`.\n   - Return the resulting Z3 expression.",
  "MoveCorrespondingToStatement": "1. **Goal:** Handle `MOVE CORR`.\n2. **Implementation:**\n   - **This is a complex operation requiring introspection of group items.**\n   - **Step 1:** Visit the `MoveCorrespondingToSendingArea` to get the name of the source group item (`source_group_name`).\n   - **Step 2:** Get the list of receiving `Identifier`s (destination group items).\n   - **Step 3:** For each `dest_group_name`:\n     - Find all elementary items under `source_group_name` by inspecting `self.pic_info` (e.g., all keys starting with `source_group_name + '.'`).\n     - For each source elementary item, find if an item with the *same base name* exists under `dest_group_name`.\n     - If a match is found (e.g., `source_group.ITEM-A` and `dest_group.ITEM-A`), generate a standard MOVE constraint between them as if it were `MOVE source_group.ITEM-A TO dest_group.ITEM-A`.",
  "MoveCorrespondingToSendingArea": "1. **Goal:** Get the name of the sending group item.\n2. **Implementation:**\n   - Visit the `Identifier` child.\n   - Return the resolved variable name string.",
  "StopStatement": "1. **Goal:** Model a STOP RUN statement.\n2. **Implementation:**\n   - This signifies the end of an execution path.\n   - No Z3 constraints are generated. This can be used as a signal to the analysis engine to consider this path complete. Log the action.",
  "OnSizeErrorPhrase": "1. **Goal:** Handle ON SIZE ERROR logic.\n2. **Implementation:**\n   - This is part of a parent statement (e.g., COMPUTE). The parent must first generate the condition for a size error.\n   - Let `size_error_cond` be the Z3 boolean for the error.\n   - The parent statement will create a new path: `error_path = z3.And(path_condition, size_error_cond)`.\n   - This visitor will then iterate its `Statement` children and call `self.visit(child, error_path)`.",
  "NotOnSizeErrorPhrase": "1. **Goal:** Handle NOT ON SIZE ERROR logic.\n2. **Implementation:**\n   - This is the counterpart to `OnSizeErrorPhrase`.\n   - Let `size_error_cond` be the Z3 boolean for the error.\n   - The parent statement will create a new path: `no_error_path = z3.And(path_condition, z3.Not(size_error_cond))`.\n   - This visitor will then iterate its `Statement` children and call `self.visit(child, no_error_path)`.",
  "ArithmeticExpression": "1. **Goal:** Build a Z3 arithmetic expression from the AST.\n2. **Implementation:**\n   - This follows standard shunting-yard/recursive descent logic for expression parsing.\n   - Visit the first `MultDivs` child to get an initial Z3 expression (`result`).\n   - Iterate through the `PlusMinus` children.\n     - For each `PlusMinus` child:\n       - Visit its `MultDivs` grandchild to get the Z3 expression for the operand (`operand`).\n       - If the operator is `+`, update `result = result + operand`.\n       - If the operator is `-`, update `result = result - operand`.\n   - Return the final `result` Z3 expression.",
  "PlusMinus": "1. **Goal:** Wrapper for an operator and its operand.\n2. **Implementation:**\n   - This visitor is not called directly. Its parent `ArithmeticExpression` will access its children.",
  "MultDivs": "1. **Goal:** Handle multiplication and division within an arithmetic expression.\n2. **Implementation:**\n   - Visit the first `Powers` child to get an initial Z3 expression (`result`).\n   - Iterate through the `MultDiv` children.\n     - For each `MultDiv` child:\n       - Visit its `Powers` grandchild to get the Z3 expression for the operand (`operand`).\n       - If the operator is `*`, update `result = result * operand`.\n       - If the operator is `/`, update `result = result / operand`. Note: This will promote the expression to `z3.Real`. The logic in `ComputeStatement` must handle this.\n   - Return the final `result` Z3 expression.",
  "MultDiv": "1. **Goal:** Wrapper for an operator and its operand.\n2. **Implementation:**\n   - This visitor is not called directly. Its parent `MultDivs` will access its children.",
  "Powers": "1. **Goal:** Handle exponentiation within an arithmetic expression.\n2. **Implementation:**\n   - Visit the `Basis` child to get the base expression (`base_expr`).\n   - Check for a leading `+` or `-` sign and apply it if necessary.\n   - Iterate through the `Power` children.\n     - For each `Power` child, visit its `Basis` grandchild to get the exponent (`exp_expr`).\n     - Update the result: `base_expr = base_expr ** exp_expr`.\n   - Return the final Z3 expression.",
  "Power": "1. **Goal:** Wrapper for the exponentiation operator and its operand.\n2. **Implementation:**\n   - This visitor is not called directly. Its parent `Powers` will access its children.",
  "Basis": "1. **Goal:** The base unit of an arithmetic expression (a literal, a variable, or a parenthesized expression).\n2. **Implementation:**\n   - Check the type of the child.\n   - If `LPARENCHAR`, visit the nested `ArithmeticExpression` child and return its result.\n   - If `Identifier`, visit it to get the Z3 variable for its current value, and return it.\n   - If `literal`, visit it to get the Z3 literal, and return it.",
  "Condition": "1. **Goal:** Build a Z3 boolean expression for a potentially complex condition.\n2. **Implementation:**\n   - Visit the first `CombinableCondition` child to get an initial Z3 boolean expression (`result`).\n   - Iterate through the `AndOrCondition` children.\n     - For each child, visit its `CombinableCondition` grandchild to get the next operand (`operand`).\n     - If the operator is `AND`, update `result = z3.And(result, operand)`.\n     - If the operator is `OR`, update `result = z3.Or(result, operand)`.\n   - Return the final `result` Z3 boolean expression.",
  "AndOrCondition": "1. **Goal:** Wrapper for a logical operator and its operand.\n2. **Implementation:**\n   - This visitor is not called directly. Its parent `Condition` will access its children.",
  "CombinableCondition": "1. **Goal:** Handle a simple condition, possibly with a `NOT`.\n2. **Implementation:**\n   - Visit the `SimpleCondition` child to get its Z3 boolean expression (`result`).\n   - If the `NOT` keyword is present, return `z3.Not(result)`.\n   - Otherwise, return `result`.",
  "SimpleCondition": "1. **Goal:** Handle a parenthesized condition or a relation condition.\n2. **Implementation:**\n   - If the child is `LPARENCHAR`, visit the nested `Condition` and return its result.\n   - Otherwise, visit the `RelationCondition` child and return its result.",
  "RelationCondition": "1. **Goal:** Dispatch to a specific relational condition visitor.\n2. **Implementation:**\n   - This is a wrapper node.\n   - Visit its single child (e.g., `RelationArithmeticComparison`) and return the result: `self.visit(self._get_first_child(node), path_condition)`.",
  "RelationSignCondition": "1. **Goal:** Generate constraints for `IS POSITIVE/NEGATIVE/ZERO`.\n2. **Implementation:**\n   - Visit the `ArithmeticExpression` child to get its Z3 expression (`expr`).\n   - Based on the keyword (`POSITIVE`, `NEGATIVE`, `ZERO`):\n     - `POSITIVE`: `result = (expr > 0)`.\n     - `NEGATIVE`: `result = (expr < 0)`.\n     - `ZERO`: `result = (expr == 0)`.\n   - If the `NOT` keyword is present, wrap the result: `result = z3.Not(result)`.\n   - Return the `result` Z3 boolean expression.",
  "RelationArithmeticComparison": "1. **Goal:** Generate constraints for `expr1 > expr2`.\n2. **Implementation:**\n   - Visit the first `ArithmeticExpression` child to get `lhs_expr`.\n   - Visit the `RelationalOperator` child to get the Z3 operator function (e.g., `lambda a, b: a > b`).\n   - Visit the second `ArithmeticExpression` child to get `rhs_expr`.\n   - Apply the operator: `result = operator_func(lhs_expr, rhs_expr)`.\n   - Return the `result` Z3 boolean expression.",
  "RelationCombinedComparison": "1. **Goal:** Not a standard COBOL feature, but if needed, it would parse `A > (B OR C)`.\n2. **Implementation:**\n   - This is complex. It would involve creating multiple comparisons `A > B` and `A > C` and combining them with the specified `AND` or `OR` operator.",
  "RelationCombinedCondition": "1. **Goal:** See `RelationCombinedComparison`.\n2. **Implementation:**\n   - This would be visited by `RelationCombinedComparison` to build the combined right-hand side.",
  "RelationalOperator": "1. **Goal:** Parse the relational operator and return a corresponding lambda function.\n2. **Implementation:**\n   - Analyze the `Source Text` or children of the node.\n   - Based on the operator text (e.g., `GREATER THAN`, `>`), return a lambda that can be applied to two Z3 expressions.\n   - Example:\n     - If `>` or `GREATER`: `return lambda a, b: a > b`.\n     - If `=` or `EQUAL`: `return lambda a, b: a == b`.\n     - If `NOT EQUAL`: `return lambda a, b: a != b` or `return lambda a, b: z3.Not(a == b)`.\n   - This lambda is then used by the parent visitor.",
  "Abbreviation": "1. **Goal:** Handle abbreviated combined conditions like `IF A > B AND < C`.\n2. **Implementation:**\n   - This is an advanced parsing feature that requires context from the previous condition.\n   - The visitor would need to access the last explicitly stated subject (`A` in the example) and use it for the current comparison (`A < C`). The implementation would be stateful and complex.",
  "Identifier": "1. **Goal:** Resolve a (potentially qualified) variable name to its Z3 representation.\n2. **Implementation:**\n   - This is a critical read operation.\n   - Visit the child node (e.g., `QualifiedDataName`). This visit should return the fully resolved, dot-separated name string (e.g., 'MY-GROUP.MY-VAR').\n   - Call `self._get_current_z3_var(resolved_name)` to get the Z3 variable for the most recent version of this data item.\n   - Return the Z3 variable.",
  "TableCall": "1. **Goal:** Handle array/table element access.\n2. **Implementation:**\n   - **This requires a model of the table in Z3.** A `z3.Array` is the most appropriate representation.\n   - The `OCCURS` clause (not in this grammar subset but implied by tables) would define a `z3.Array` mapping an index to a value.\n   - Visit `QualifiedDataName` to get the table's base name.\n   - Visit the `Subscript` children to get the Z3 expressions for the indices.\n   - Use `z3.Select(table_array, index_expr)` to access the element.\n   - Return the resulting Z3 expression.",
  "FunctionCall": "1. **Goal:** Handle intrinsic function calls.\n2. **Implementation:**\n   - Get the `FunctionName`.\n   - Based on the function name, map it to a Z3 function or a custom-defined uninterpreted function.\n     - e.g., `SQRT` -> `z3.Sqrt` (if args are Real), or a custom implementation.\n   - Visit the `Argument` children to get their Z3 expressions.\n   - Apply the Z3 function to the argument expressions and return the result.",
  "ReferenceModifier": "1. **Goal:** Handle substring operations `(start:length)`.\n2. **Implementation:**\n   - The identifier being modified must resolve to a `z3.String` or `z3.BitVec`.\n   - Visit `CharacterPosition` (`ArithmeticExpression`) to get the starting position Z3 expression (`start_expr`).\n   - Visit `Length` (`ArithmeticExpression`) to get the length Z3 expression (`len_expr`).\n   - Use Z3's `z3.SubString` or `z3.Extract` function on the base variable.\n   - `result = z3.SubString(base_string_var, start_expr - 1, len_expr)` (COBOL is 1-based).\n   - Return the `result` Z3 expression.",
  "CharacterPosition": "1. **Goal:** Get the Z3 expression for a starting position.\n2. **Implementation:**\n   - Visit the `ArithmeticExpression` child and return its result.",
  "Length": "1. **Goal:** Get the Z3 expression for a length.\n2. **Implementation:**\n   - Visit the `ArithmeticExpression` child and return its result.",
  "Subscript": "1. **Goal:** Get the Z3 expression for a table subscript/index.\n2. **Implementation:**\n   - Visit the child (`integerLiteral`, `QualifiedDataName`, `ArithmeticExpression`) and return its Z3 value.",
  "Argument": "1. **Goal:** Get the Z3 expression for a function argument.\n2. **Implementation:**\n   - Visit the child (`literal`, `Identifier`, etc.) and return its Z3 value.",
  "QualifiedDataName": "1. **Goal:** Dispatch to the correct qualified name format visitor.\n2. **Implementation:**\n   - This is a wrapper. Visit its child (`QualifiedDataNameFormat1`, etc.) and return the result.",
  "QualifiedDataNameFormat1": "1. **Goal:** Resolve a fully qualified data name like `CHILD OF PARENT`.\n2. **Implementation:**\n   - Get the base `DataName` text.\n   - Get the list of qualifier names from the `QualifiedInData` children.\n   - Call `self.resolve_variable(base_name, qualifiers)` to get the canonical, dot-separated full name.\n   - Return this full name string. The caller (`Identifier`) will then fetch the Z3 var.",
  "QualifiedDataNameFormat2": "1. **Goal:** Resolve a paragraph name within a section.\n2. **Implementation:**\n   - For Z3 constraint generation, paragraph names are typically labels, not variables.\n   - Return a unique string representing the qualified name, e.g., `SECTION.PARAGRAPH`.",
  "QualifiedDataNameFormat3": "1. **Goal:** Resolve a text name within a library.\n2. **Implementation:**\n   - This is for `COPY` books. Assumed to be handled by a preprocessor.\n   - If encountered, raise an error or return a unique name.",
  "QualifiedDataNameFormat4": "1. **Goal:** Handle the `LINAGE-COUNTER` special register.\n2. **Implementation:**\n   - `LINAGE-COUNTER` is a special register. It should be pre-declared as a Z3 variable in `__init__`.\n   - This visitor should return the canonical name 'LINAGE-COUNTER'.",
  "QualifiedInData": "1. **Goal:** A wrapper for `InData` or `InTable`.\n2. **Implementation:**\n   - Visit the child and return its result.",
  "InData": "1. **Goal:** Extract a qualifier name from an `IN/OF` clause.\n2. **Implementation:**\n   - Visit the `DataName` child and return its `Source Text`.",
  "InFile": "1. **Goal:** Extract a file name qualifier.\n2. **Implementation:**\n   - Return the file name text.",
  "InMnemonic": "1. **Goal:** Extract a mnemonic name qualifier.\n2. **Implementation:**\n   - Return the mnemonic name text.",
  "InSection": "1. **Goal:** Extract a section name qualifier.\n2. **Implementation:**\n   - Return the section name text.",
  "InLibrary": "1. **Goal:** Extract a library name qualifier.\n2. **Implementation:**\n   - Return the library name text.",
  "InTable": "1. **Goal:** Handle qualification by a table, e.g., `ITEM OF TABLE(I)`.\n2. **Implementation:**\n   - This is complex. The resolved name depends on the value of the subscript. This level of dynamic resolution is beyond simple static name resolution.",
  "Literal": "1. **Goal:** Convert a COBOL literal into a Z3 literal.\n2. **Implementation:**\n   - Visit the specific literal child (`NONNUMERICLITERAL`, `FigurativeConstant`, etc.).\n   - **NONNUMERICLITERAL:** Parse the string inside the quotes. Return `z3.StringVal(parsed_string)`.\n   - **NumericLiteral:** Parse the number. If it has a decimal, return `z3.RealVal(text)`. Otherwise, return `z3.IntVal(text)`.\n   - **BooleanLiteral:** Return `z3.BoolVal(True)` or `z3.BoolVal(False)`.\n   - **FigurativeConstant:** Handle `SPACE`, `ZERO`, etc. Return `z3.StringVal(' ')` or `z3.IntVal(0)` respectively.",
  "figurativeConstant": "1. **Goal:** Convert a figurative constant to a Z3 literal.\n2. **Implementation:**\n   - Get the constant's text (e.g., `SPACE`, `ZERO`, `HIGH-VALUE`).\n   - Return the corresponding Z3 literal.\n     - `SPACE(S)`: `z3.StringVal(' ')` (or a string of spaces if the context implies a length).\n     - `ZERO(S), ZEROES`: `z3.IntVal(0)` or `z3.StringVal('0')` depending on the context of its use.\n     - `HIGH-VALUE`: `z3.BitVecVal(0xFF... , size)` or `z3.StringVal` with `chr(255)` characters. Requires context for size.\n     - `LOW-VALUE`: `z3.BitVecVal(0, size)` or `z3.StringVal` with `chr(0)` characters.\n     - `QUOTE(S)`: `z3.StringVal('\"')`.\n     - `NULL(S)`: Represents a pointer value, typically 0.",
  "BooleanLiteral": "1. **Goal:** Convert a boolean literal to a Z3 literal.\n2. **Implementation:**\n   - If the token is `TRUE`, return `z3.BoolVal(True)`.\n   - If the token is `FALSE`, return `z3.BoolVal(False)`.",
  "ConditionName": "1. **Goal:** Handle a Level 88 condition name.\n2. **Implementation:**\n   - This is a lookup, not a direct value.\n   - The declaration of the `88` item would have created a Z3 boolean expression (e.g., `(PARENT_VAR >= 10) AND (PARENT_VAR <= 20)`) and stored it in a map like `self.condition_names`.\n   - This visitor looks up the `ConditionName` text in that map and returns the associated Z3 boolean expression.",
  "DataName": "1. **Goal:** Return the text of a data name.\n2. **Implementation:**\n   - Visit the `CobolWord` child.\n   - Return its `Source Text`."
}